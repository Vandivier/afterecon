---
title: Science Problems: Humility Failure
date: 2016-07-21
author: John Vandivier
status: publish
---

This article discusses the failure of practicing scientists and data analysts to correct for a well known problem: Their own overconfidence.\r\n\r\nThis article has 3 sections:\r\n<ol>\r\n 	<li>Intro</li>\r\n 	<li>The Problem</li>\r\n 	<li>One Possible Solution</li>\r\n</ol>\r\n&nbsp;\r\n<p style=\"text-align: center;\">Section 1: Intro</p>\r\nHere are a couple cool things disregarded all too often in science and data analysis:\r\n<ol>\r\n 	<li>Small or hypersmall data sets (1-100 observations)</li>\r\n 	<li>Humility</li>\r\n</ol>\r\nI've talked about how <a href=\"http://www.afterecon.com/economics-and-finance/meta-economics/\">small data is cool</a> in the past so let me talk about humility today.\r\n\r\nGiven a large data set, what are the odds that an analyst will foreknow the variables of interest and their likely shapes?\r\n\r\nNot only is the likelihood small, the analyst will tend to <a href=\"https://en.wikipedia.org/wiki/Overconfidence_effect\">overestimate</a> their own ability.\r\n\r\nMoreover, the patterns they search for will have selection bias. The tends toward <a href=\"https://en.wikipedia.org/wiki/Cherry_picking\">cherry picking</a> and may contain self-serving bias, with or without malintent.\r\n\r\nThe obvious correction is to allow the data to tell it's own story. How can we do that? Instead of allowing the analyst to check for patterns, allow a computer to check all possible patterns.\r\n\r\nA factorial regression would be an algorithm which allows a computer to run every combination of regressions among a data set.\r\n\r\nA primitive factorial regression would be a Factorial OLS. Given 3 columns in a data set, a machine would run 3! = 3*2*1 OLS regressions.\r\n\r\nA more sophisticated program would allow for k types of regressions (OLS, quadratic, cubic, log...), so a more full factorial analysis might be k(n!).\r\n\r\n&nbsp;\r\n<p style=\"text-align: center;\">Section 2: The Problem</p>\r\nThe computer would assert the ideal regression, rather than the biased whims of an analyst.\r\n\r\nSuch an analysis would represent a humble approach: Learning from the data instead of searching for evidence of a preferred answer.\r\n\r\n<a href=\"http://stats.stackexchange.com/questions/68181/performing-all-possible-regressions-in-r\">Here is a data analysis stack exchange post</a> where an individual asks how to do exactly what I described as a factorial regression, using R.\r\n\r\nHe gets shot down by like everyone.\r\n\r\nOne reason rings out: data-mining bias.\r\n\r\nHowever, I am here to tell you: No amount of data-mining bias can overcome the benefits of data-mining.\r\n\r\nWhoa what? Yes.\r\n\r\nThe error introduced by randomly guessing can be corrected for through <a href=\"https://en.wikipedia.org/wiki/Bonferroni_correction\">Bonferroni</a> or <a href=\"https://en.wikipedia.org/wiki/%C5%A0id%C3%A1k_correction\">Sidak</a> Correction.\r\n\r\nHowever, none of these corrections will penalize the first-winning regression in such a way that the second-winning regression ever becomes preferred.\r\n\r\nCorrections will reduce our confidence in the first-winning regression, and perhaps to such an extent that we see no significant winners; but it will always preserve the rank order of model quality.\r\n\r\nI'm certainly a pragmatist: If your intuition happens to lead you into a great model, use it! Bayesian results are often more straightforward to interpret, test, and use. However, there is forever some element of bias which can't be rooted out from the Bayesian approach.\r\n\r\nIn real life, however, the benefits of many models outweigh whatever insignificant bias might remain from a Bayesian input.\r\n\r\nOn the other hand, in some situations a Bayesian model might be more difficult: What if you are so unfamiliar with a data context or so unconvinced by any apparent intuition that you can't generate a meaningful Bayesian input, hypothesis, or theory? Then a pure mathematical descriptive, exploratory approach may be best.\r\n\r\nA factor analysis, including a factor regression, is a great addition to any <a href=\"https://en.wikipedia.org/wiki/Exploratory_data_analysis\">Exploratory Data Analysis</a> (EDA). Why choose between Bayes and Bonferroni? Use them both in your EDA and discuss the differences!\r\n\r\nNow, be careful: Data-mining can result in some weird models. These models should generally not be interpreted causally, or even at all, without further research and causal reasoning.\r\n\r\nHowever, data-mined models will produce mathematically optimal forecasts and expectations when given new data that fits the model.\r\n\r\nSimplification makes interpretation easier, but it doesn't make for more accurate analysis or forecasting. Data mining models makes interpretation hard, but it's technically useful.\r\n\r\nProbably some balance is efficient: I'm just trying to argue against dismissing data mining out of hand. It's a useful technique.\r\n\r\nSimplification of models into theory can also happen in many ways: I vote for emergent simplification over imposed simplification:\r\n<ul>\r\n 	<li>Emergent simplification takes an algorithmically produced model and systematically eliminates minimally beneficial parameters until a useful or meaningful model remains.</li>\r\n 	<li>Imposed simplification takes the intuition of an analyst and seeks to extract affirmation out of a data set.</li>\r\n</ul>\r\n&nbsp;\r\n<p style=\"text-align: center;\">Section 3: One Possible Solution</p>\r\nGoing back to how this program might work...k(n!) is just the beginning! Given a data set with age as a column, a skilled analyst might recognize that certain factors might be increasing or decreasing in marginal age.\r\n\r\nSo a cool machine would be able to generate age^2 and age^3 and test those as factors.\r\n\r\nThe possibilities are infinite - which is kind of cool and also kind of bad, because that can make such a program hard to create.\r\n\r\nOne solution would be a measure of complexity and a user-specified complexity cap.\r\n\r\nThe accuracy of a model would be reasonably expected to gain with a diminishing marginal effect with respect to complexity.\r\n\r\nThe input of processing power and time required to execute a program of linearly increasing complexity is reasonably expected to increase exponentially.\r\n\r\nIn combination with small data, however, this is a one-two punch for extracting powerful, user-tailored data in a cheap, feasible way.\r\n\r\nThis sort of analysis can yield insightful and unexpected results. Here's another advantage: It destroys overconfidence bias.\r\n\r\nWhy? Because the analyst has not asserted a hypothesis to test and they have not selected the search space of models.\r\n\r\nNow, it may still be a fair criticism that the analyst may have selected the data set, but there are a few simple retorts to such a criticism:\r\n<ol>\r\n 	<li>No I didn't! Many large data sets are established and analysts are essentially data-takers.</li>\r\n 	<li>Yes. On purpose! Data optimized for application is often selected from a small pool on purpose - eg \"I only care about my customers, not the whole market\"</li>\r\n 	<li>True, but the result is easily reproduced with other data sets.</li>\r\n 	<li>True, but it's better than if I had a weird data set <em>and</em> overconfidence bias!</li>\r\n</ol>\r\nOf course, none of those retorts hold up to evidence that the data set is truly tampered with.\r\n\r\nTangentially: Genetic optimizations are kind of like this factorial thing, because models can emerge from data rather than being imposed on the data.\r\n\r\nGenetic optimization is one kind of regression that scientists are usually pretty interested in using it.\r\n\r\nThere's also an awesome Javascript library for it. <a href=\"http://subprotocol.com/system/genetic-regression-curve.html\">Demo</a>. <a href=\"https://github.com/subprotocol/genetic-js\">Github</a>.